use crate::decoder::WasmDecoder;
use crate::error::DecodingError;
use crate::types::{RefType, ValType};

#[derive(Debug, PartialEq, Clone)]
pub struct Expr(pub Vec<Instr>);

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct MemArg {
    pub align: u32,
    pub offset: u32,
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum BlockType {
    Void,
    ValType(ValType),
    NewType(u64),
}

#[derive(Debug, PartialEq, Clone)]
pub enum Instr {
    Unreachable,
    Nop,
    Block(BlockType, Vec<Instr>),
    Loop(BlockType, Vec<Instr>),
    IfElse(BlockType, Vec<Instr>, Option<Vec<Instr>>),
    Branch(u32),
    BranchIf(u32),
    BranchTable(Vec<u32>, u32),
    Return,
    Call(u32),
    CallIndirect(u32, u32),
    ReturnCall(u32),
    ReturnCallIndirect(u32, u32),
    CallRef(u32),
    ReturnCallRef(u32),
    Drop,
    Select,
    SelectT(Vec<ValType>),
    LocalGet(u32),
    LocalSet(u32),
    LocalTee(u32),
    GlobalGet(u32),
    GlobalSet(u32),
    TableGet(u32),
    TableSet(u32),

    MemorySize,
    MemoryGrow,

    I32Const(i32),
    I64Const(i64),
    F32Const(f32),
    F64Const(f64),

    I32Eqz,
    I32Eq,
    I32Ne,
    I32LtS,
    I32LtU,
    I32GtS,
    I32GtU,
    I32LeS,
    I32LeU,
    I32GeS,
    I32GeU,

    I64Eqz,
    I64Eq,
    I64Ne,
    I64LtS,
    I64LtU,
    I64GtS,
    I64GtU,
    I64LeS,
    I64LeU,
    I64GeS,
    I64GeU,

    F32Eq,
    F32Ne,
    F32Lt,
    F32Gt,
    F32Le,
    F32Ge,

    F64Eq,
    F64Ne,
    F64Lt,
    F64Gt,
    F64Le,
    F64Ge,

    I32Clz,
    I32Ctz,
    I32Popcnt,
    I32Add,
    I32Sub,
    I32Mul,
    I32DivS,
    I32DivU,
    I32RemS,
    I32RemU,
    I32And,
    I32Or,
    I32Xor,
    I32Shl,
    I32ShrS,
    I32ShrU,
    I32Rotl,
    I32Rotr,

    I64Clz,
    I64Ctz,
    I64Popcnt,
    I64Add,
    I64Sub,
    I64Mul,
    I64DivS,
    I64DivU,
    I64RemS,
    I64RemU,
    I64And,
    I64Or,
    I64Xor,
    I64Shl,
    I64ShrS,
    I64ShrU,
    I64Rotl,
    I64Rotr,

    F32Abs,
    F32Neg,
    F32Ceil,
    F32Floor,
    F32Trunc,
    F32Nearest,
    F32Sqrt,
    F32Add,
    F32Sub,
    F32Mul,
    F32Div,
    F32Min,
    F32Max,
    F32Copysign,

    F64Abs,
    F64Neg,
    F64Ceil,
    F64Floor,
    F64Trunc,
    F64Nearest,
    F64Sqrt,
    F64Add,
    F64Sub,
    F64Mul,
    F64Div,
    F64Min,
    F64Max,
    F64Copysign,

    I32WrapI64,
    I32TruncF32S,
    I32TruncF32U,
    I32TruncF64S,
    I32TruncF64U,
    I64ExtendI32S,
    I64ExtendI32U,
    I64TruncF32S,
    I64TruncF32U,
    I64TruncF64S,
    I64TruncF64U,
    F32ConvertI32S,
    F32ConvertI32U,
    F32ConvertI64S,
    F32ConvertI64U,
    F32DemoteF64,
    F64ConvertI32S,
    F64ConvertI32U,
    F64ConvertI64S,
    F64ConvertI64U,
    F64PromoteF32,
    I32ReinterpretF32,
    I64ReinterpretF64,
    F32ReinterpretI32,
    F64ReinterpretI64,

    I32Extend8S,
    I32Extend16S,
    I64Extend8S,
    I64Extend16S,
    I64Extend32S,

    RefNull(RefType),
    RefIsNull,
    RefFunc(u32),
    RefEq,
    RefAsNonNull,
    BrOnNull(u32),
    BrOnNonNull(u32),

    I32Load(MemArg),
    I64Load(MemArg),
    F32Load(MemArg),
    F64Load(MemArg),
    I32Load8S(MemArg),
    I32Load8U(MemArg),
    I32Load16S(MemArg),
    I32Load16U(MemArg),
    I64Load8S(MemArg),
    I64Load8U(MemArg),
    I64Load16S(MemArg),
    I64Load16U(MemArg),
    I64Load32S(MemArg),
    I64Load32U(MemArg),
    I32Store(MemArg),
    I64Store(MemArg),
    F32Store(MemArg),
    F64Store(MemArg),
    I32Store8(MemArg),
    I32Store16(MemArg),
    I64Store8(MemArg),
    I64Store16(MemArg),
    I64Store32(MemArg),

    I32TruncSatF32S,
    I32TruncSatF32U,
    I32TruncSatF64S,
    I32TruncSatF64U,
    I64TruncSatF32S,
    I64TruncSatF32U,
    I64TruncSatF64S,
    I64TruncSatF64U,

    MemoryInit(u32),
    MemoryDrop(u32),
    MemoryCopy,
    MemoryFill,
    TableInit(u32, u32),
    ElemDrop(u32),
    TableCopy(u32, u32),
    TableGrow(u32),
    TableSize(u32),
    TableFill(u32),

    V128Load(MemArg),
    V128Load8x8S(MemArg),
    V128Load8x8U(MemArg),
    V128Load16x4S(MemArg),
    V128Load16x4U(MemArg),
    V128Load32x2S(MemArg),
    V128Load32x2U(MemArg),
    V128Load8Splat(MemArg),
    V128Load16Splat(MemArg),
    V128Load32Splat(MemArg),
    V128Load64Splat(MemArg),
    V128Store(MemArg),
    V128Const(i128),

    I8x16Shuffle([u8; 16]),
    I8x16Swizzle,
    
    I8x16Splat,
    I16x8Splat,
    I32x4Splat,
    I64x2Splat,
    F32x4Splat,
    F64x2Splat,

    I8x16ExtractLaneS(u8),
    I8x16ExtractLaneU(u8),
    I8x16ReplaceLane(u8),
    I16x8ExtractLaneS(u8),
    I16x8ExtractLaneU(u8),
    I16x8ReplaceLane(u8),
    I32x4ExtractLane(u8),
    I32x4ReplaceLane(u8),
    I64x2ExtractLane(u8),
    I64x2ReplaceLane(u8),
    F32x4ExtractLane(u8),
    F32x4ReplaceLane(u8),
    F64x2ExtractLane(u8),
    F64x2ReplaceLane(u8),

    I8x16Eq,
    I8x16Ne,
    I8x16LtS,
    I8x16LtU,
    I8x16GtS,
    I8x16GtU,
    I8x16LeS,
    I8x16LeU,
    I8x16GeS,
    I8x16GeU,

    I16x8Eq,
    I16x8Ne,
    I16x8LtS,
    I16x8LtU,
    I16x8GtS,
    I16x8GtU,
    I16x8LeS,
    I16x8LeU,
    I16x8GeS,
    I16x8GeU,

    I32x4Eq,
    I32x4Ne,
    I32x4LtS,
    I32x4LtU,
    I32x4GtS,
    I32x4GtU,
    I32x4LeS,
    I32x4LeU,
    I32x4GeS,
    I32x4GeU,

    F32x4Eq,
    F32x4Ne,
    F32x4Lt,
    F32x4Gt,
    F32x4Le,
    F32x4Ge,

    F64x2Eq,
    F64x2Ne,
    F64x2Lt,
    F64x2Gt,
    F64x2Le,
    F64x2Ge,

    V128Not,
    V128And,
    V128Andnot,
    V128Or,
    V128Xor,
    V128Bitselect,
    V128AnyTrue,

    V128Load8Lane(MemArg, u8),
    V128Load16Lane(MemArg, u8),
    V128Load32Lane(MemArg, u8),
    V128Load64Lane(MemArg, u8),
    V128Store8Lane(MemArg, u8),
    V128Store16Lane(MemArg, u8),
    V128Store32Lane(MemArg, u8),
    V128Store64Lane(MemArg, u8),

    V128Load32Zero(MemArg),
    V128Load64Zero(MemArg),

    F32x4DemoteF64x2Zero,
    F64x2PromoteLowF32x4,

    I8x16Abs,
    I8x16Neg,
    I8x16Popcnt,
    I8x16AllTrue,
    I8x16Bitmask,
    I8x16NarrowI16x8S,
    I8x16NarrowI16x8U,

    F32x4Ceil,
    F32x4Floor,
    F32x4Trunc,
    F32x4Nearest,

    I8x16Shl,
    I8x16ShrS,
    I8x16ShrU,
    I8x16Add,
    I8x16AddSatS,
    I8x16AddSatU,
    I8x16Sub,
    I8x16SubSatS,
    I8x16SubSatU,

    F64x2Ceil,
    F64x2Floor,

    I8x16MinS,
    I8x16MinU,
    I8x16MaxS,
    I8x16MaxU,

    F64x2Trunc,

    I8x16AvgrU,

    I16x8ExtaddPairwiseI8x16S,
    I16x8ExtaddPairwiseI8x16U,
    I32x4ExtaddPairwiseI16x8S,
    I32x4ExtaddPairwiseI16x8U,

    I16x8Abs,
    I16x8Neg,
    I16x8Q15mulrSatS,
    I16x8AllTrue,
    I16x8Bitmask,
    I16x8NarrowI32x4S,
    I16x8NarrowI32x4U,
    I16x8ExtendLowI8x16S,
    I16x8ExtendHighI8x16S,
    I16x8ExtendLowI8x16U,
    I16x8ExtendHighI8x16U,

    I16x8Shl,
    I16x8ShrS,
    I16x8ShrU,
    I16x8Add,
    I16x8AddSatS,
    I16x8AddSatU,
    I16x8Sub,
    I16x8SubSatS,
    I16x8SubSatU,
    F64x2Nearest,
    I16x8Mul,
    I16x8MinS,
    I16x8MinU,
    I16x8MaxS,
    I16x8MaxU,
    I16x8AvgrU,

    I16x8ExtmulLowI8x16S,
    I16x8ExtmulHighI8x16S,
    I16x8ExtmulLowI8x16U,
    I16x8ExtmulHighI8x16U,

    I32x4Abs,
    I32x4Neg,
    I32x4AllTrue,
    I32x4Bitmask,

    I32x4ExtendLowI16x8S,
    I32x4ExtendHighI16x8S,
    I32x4ExtendLowI16x8U,
    I32x4ExtendHighI16x8U,

    I32x4Shl,
    I32x4ShrS,
    I32x4ShrU,
    I32x4Add,
    I32x4Sub,
    I32x4Mul,
    I32x4MinS,
    I32x4MinU,
    I32x4MaxS,
    I32x4MaxU,
    I32x4DotI16x8S,

    I32x4ExtmulLowI16x8S,
    I32x4ExtmulHighI16x8S,
    I32x4ExtmulLowI16x8U,
    I32x4ExtmulHighI16x8U,

    I64x2Abs,
    I64x2Neg,
    I64x2AllTrue,
    I64x2Bitmask,

    I64x2ExtendLowI32x4S,
    I64x2ExtendHighI32x4S,
    I64x2ExtendLowI32x4U,
    I64x2ExtendHighI32x4U,

    I64x2Shl,
    I64x2ShrS,
    I64x2ShrU,
    I64x2Add,
    I64x2Sub,
    I64x2Mul,
    I64x2Eq,
    I64x2Ne,
    I64x2LtS,
    I64x2GtS,
    I64x2LeS,
    I64x2GeS,

    I64x2ExtmulLowI32x4S,
    I64x2ExtmulHighI32x4S,
    I64x2ExtmulLowI32x4U,
    I64x2ExtmulHighI32x4U,

    F32x4Abs,
    F32x4Neg,
    F32x4Sqrt,
    F32x4Add,
    F32x4Sub,
    F32x4Mul,
    F32x4Div,
    F32x4Min,
    F32x4Max,
    F32x4Pmin,
    F32x4Pmax,

    F64x2Abs,
    F64x2Neg,
    F64x2Sqrt,
    F64x2Add,
    F64x2Sub,
    F64x2Mul,
    F64x2Div,
    F64x2Min,
    F64x2Max,
    F64x2Pmin,
    F64x2Pmax,

    I32x4TruncSatF32x4S,
    I32x4TruncSatF32x4U,
    F32x4ConvertI32x4S,
    F32x4ConvertI32x4U,
    I32x4TruncSatF64x2SZero,
    I32x4TruncSatF64x2UZero,

    F64x2ConvertLowI32x4S,
    F64x2ConvertLowI32x4U,

    I8x16RelaxedSwizzle,
    I32x4RelaxedTruncF32x4S,
    I32x4RelaxedTruncF32x4U,
    I32x4RelaxedTruncF64x2S,
    I32x4RelaxedTruncF64x2U,
    F32x4RelaxedMadd,
    F32x4RelaxedNmadd,
    F64x2RelaxedMadd,
    F64x2RelaxedNmadd,
    I8x16RelaxedLaneselect,
    I16x8RelaxedLaneselect,
    I32x4RelaxedLaneselect,
    I64x2RelaxedLaneselect,
    F32x4RelaxedMin,
    F32x4RelaxedMax,
    F64x2RelaxedMin,
    F64x2RelaxedMax,
    I16x8RelaxedQ15mulrS,
    I16x8RelaxedDotI8x16I7x16S,
    I32x4RelaxedDotI8x16I7x16AddS,
}

fn unexpected<T>(name: &str) -> Result<T, DecodingError> {
    Err(format!("unexpected: {}", name).into())
}

fn reserved<T>() -> Result<T, DecodingError> {
    Err("reserved".into())
}

fn unsupported<T>(name: &str) -> Result<T, DecodingError> {
    Err(format!("unsupported: {}", name).into())
}

impl<'a> WasmDecoder<'a> {
    pub fn read_expr(&mut self) -> Result<Expr, DecodingError> {
        let mut instructions = Vec::new();
        while self.peek_byte() != 0x0B {
            instructions.push(self.read_instr()?);
        }
        self.read_byte(); // skip the 0x0B byte (end marker)
        Ok(Expr(instructions))
    }

    fn read_memarg(&mut self) -> Result<MemArg, DecodingError> {
        let align = self.read_u32();
        let offset = self.read_u32();
        Ok(MemArg { align, offset })
    }

    fn read_blocktype(&mut self) -> Result<BlockType, DecodingError> {
        if self.peek_byte() == 0x40 {
            self.read_byte(); // consume the byte
            return Ok(BlockType::Void);
        }
        self.attempt(|bytes| bytes.read_val_type())
            .map(BlockType::ValType)
            .or_else(|_| {
                let x = self.read_i64();
                println!("x: {}", x);
                if x >= 0 {
                    Ok(BlockType::NewType(x as u64))
                } else {
                    Err("blocktype must be positive".into())
                }
            })
    }

    pub fn read_instr(&mut self) -> Result<Instr, DecodingError> {
        let opcode = self.read_byte();

        self.decode_instr(opcode)
            .map_err(|e| e.wrap(format!("failed to decode instr 0x{:x}", opcode)))
    }

    fn decode_instr(&mut self, opcode: u8) -> Result<Instr, DecodingError> {
        let instr = match opcode {
            0x00 => Instr::Unreachable,
            0x01 => Instr::Nop,
            0x02 => {
                let bt = self.read_blocktype()?;
                let ins = self.read_until(|bytes| bytes.read_instr(), |b| b == 0x0B)?;
                self.discard_byte(0x0B)?;
                Instr::Block(bt, ins)
            }
            0x03 => {
                let bt = self.read_blocktype()?;
                let ins = self.read_until(|bytes| bytes.read_instr(), |b| b == 0x0B)?;
                self.discard_byte(0x0B)?;
                Instr::Loop(bt, ins)
            }
            0x04 => {
                let bt = self.read_blocktype()?;
                let ins =
                    self.read_until(|bytes| bytes.read_instr(), |b| b == 0x05 || b == 0x0B)?;
                match self.read_byte() {
                    0x05 => {
                        let ins2 = self.read_until(|bytes| bytes.read_instr(), |b| b == 0x0B)?;
                        self.discard_byte(0x0B)?;
                        Instr::IfElse(bt, ins, Some(ins2))
                    }
                    0x08 => Instr::IfElse(bt, ins, None),
                    b => Err(format!("invalid if-else separator byte: {}", b))?,
                }
            }
            0x05 => unexpected("else")?, // never occurs on its own
            0x06 => reserved()?,
            0x07 => reserved()?,
            0x08 => unsupported("throw")?,
            0x09 => reserved()?,
            0x0A => unsupported("throw_ref")?,
            0x0B => unexpected("end")?, // never occurs on its own
            0x0C => Instr::Branch(self.read_u32()),
            0x0D => Instr::BranchIf(self.read_u32()),
            0x0E => Instr::BranchTable(
                self.read_vec(|bytes| Ok(bytes.read_u32()))?,
                self.read_u32(),
            ),
            0x0F => Instr::Return,

            0x10 => Instr::Call(self.read_u32()),
            0x11 => Instr::CallIndirect(self.read_u32(), self.read_u32()),
            0x12 => Instr::ReturnCall(self.read_u32()),
            0x13 => Instr::ReturnCallIndirect(self.read_u32(), self.read_u32()),
            0x14 => Instr::CallRef(self.read_u32()),
            0x15 => Instr::ReturnCallRef(self.read_u32()),
            0x16 => reserved()?,
            0x17 => reserved()?,
            0x18 => reserved()?,
            0x19 => reserved()?,
            0x1A => Instr::Drop,
            0x1B => Instr::Select,
            0x1C => Instr::SelectT(self.read_vec(|bytes| bytes.read_val_type())?),
            0x1D => reserved()?,
            0x1E => reserved()?,
            0x1F => unsupported("try_table")?,

            0x20 => Instr::LocalGet(self.read_u32()),
            0x21 => Instr::LocalSet(self.read_u32()),
            0x22 => Instr::LocalTee(self.read_u32()),
            0x23 => Instr::GlobalGet(self.read_u32()),
            0x24 => Instr::GlobalSet(self.read_u32()),
            0x25 => Instr::TableGet(self.read_u32()),
            0x26 => Instr::TableSet(self.read_u32()),
            0x27 => reserved()?,
            0x28 => Instr::I32Load(self.read_memarg()?),
            0x29 => Instr::I64Load(self.read_memarg()?),
            0x2A => Instr::F32Load(self.read_memarg()?),
            0x2B => Instr::F64Load(self.read_memarg()?),
            0x2C => Instr::I32Load8S(self.read_memarg()?),
            0x2D => Instr::I32Load8U(self.read_memarg()?),
            0x2E => Instr::I32Load16S(self.read_memarg()?),
            0x2F => Instr::I32Load16U(self.read_memarg()?),

            0x30 => Instr::I64Load8S(self.read_memarg()?),
            0x31 => Instr::I64Load8U(self.read_memarg()?),
            0x32 => Instr::I64Load16S(self.read_memarg()?),
            0x33 => Instr::I64Load16U(self.read_memarg()?),
            0x34 => Instr::I64Load32S(self.read_memarg()?),
            0x35 => Instr::I64Load32U(self.read_memarg()?),
            0x36 => Instr::I32Store(self.read_memarg()?),
            0x37 => Instr::I64Store(self.read_memarg()?),
            0x38 => Instr::F32Store(self.read_memarg()?),
            0x39 => Instr::F64Store(self.read_memarg()?),
            0x3A => Instr::I32Store8(self.read_memarg()?),
            0x3B => Instr::I32Store16(self.read_memarg()?),
            0x3C => Instr::I64Store8(self.read_memarg()?),
            0x3D => Instr::I64Store16(self.read_memarg()?),
            0x3E => Instr::I64Store32(self.read_memarg()?),
            0x3F => {
                self.discard_byte(0x00)?;
                Instr::MemorySize
            }

            0x40 => {
                self.discard_byte(0x00)?;
                Instr::MemoryGrow
            }
            0x41 => Instr::I32Const(self.read_i32()),
            0x42 => Instr::I64Const(self.read_i64()),
            0x43 => Instr::F32Const(self.read_f32()),
            0x44 => Instr::F64Const(self.read_f64()),
            0x45 => Instr::I32Eqz,
            0x46 => Instr::I32Eq,
            0x47 => Instr::I32Ne,
            0x48 => Instr::I32LtS,
            0x49 => Instr::I32LtU,
            0x4A => Instr::I32GtS,
            0x4B => Instr::I32GtU,
            0x4C => Instr::I32LeS,
            0x4D => Instr::I32LeU,
            0x4E => Instr::I32GeS,
            0x4F => Instr::I32GeU,

            0x50 => Instr::I64Eqz,
            0x51 => Instr::I64Eq,
            0x52 => Instr::I64Ne,
            0x53 => Instr::I64LtS,
            0x54 => Instr::I64LtU,
            0x55 => Instr::I64GtS,
            0x56 => Instr::I64GtU,
            0x57 => Instr::I64LeS,
            0x58 => Instr::I64LeU,
            0x59 => Instr::I64GeS,
            0x5A => Instr::I64GeU,
            0x5B => Instr::F32Eq,
            0x5C => Instr::F32Ne,
            0x5D => Instr::F32Lt,
            0x5E => Instr::F32Gt,
            0x5F => Instr::F32Le,

            0x60 => Instr::F32Ge,
            0x61 => Instr::F64Eq,
            0x62 => Instr::F64Ne,
            0x63 => Instr::F64Lt,
            0x64 => Instr::F64Gt,
            0x65 => Instr::F64Le,
            0x66 => Instr::F64Ge,
            0x67 => Instr::I32Clz,
            0x68 => Instr::I32Ctz,
            0x69 => Instr::I32Popcnt,
            0x6A => Instr::I32Add,
            0x6B => Instr::I32Sub,
            0x6C => Instr::I32Mul,
            0x6D => Instr::I32DivS,
            0x6E => Instr::I32DivU,
            0x6F => Instr::I32RemS,

            0x70 => Instr::I32RemU,
            0x71 => Instr::I32And,
            0x72 => Instr::I32Or,
            0x73 => Instr::I32Xor,
            0x74 => Instr::I32Shl,
            0x75 => Instr::I32ShrS,
            0x76 => Instr::I32ShrU,
            0x77 => Instr::I32Rotl,
            0x78 => Instr::I32Rotr,
            0x79 => Instr::I64Clz,
            0x7A => Instr::I64Ctz,
            0x7B => Instr::I64Popcnt,
            0x7C => Instr::I64Add,
            0x7D => Instr::I64Sub,
            0x7E => Instr::I64Mul,
            0x7F => Instr::I64DivS,

            0x80 => Instr::I64DivU,
            0x81 => Instr::I64RemS,
            0x82 => Instr::I64RemU,
            0x83 => Instr::I64And,
            0x84 => Instr::I64Or,
            0x85 => Instr::I64Xor,
            0x86 => Instr::I64Shl,
            0x87 => Instr::I64ShrS,
            0x88 => Instr::I64ShrU,
            0x89 => Instr::I64Rotl,
            0x8A => Instr::I64Rotr,
            0x8B => Instr::F32Abs,
            0x8C => Instr::F32Neg,
            0x8D => Instr::F32Ceil,
            0x8E => Instr::F32Floor,
            0x8F => Instr::F32Trunc,

            0x90 => Instr::F32Nearest,
            0x91 => Instr::F32Sqrt,
            0x92 => Instr::F32Add,
            0x93 => Instr::F32Sub,
            0x94 => Instr::F32Mul,
            0x95 => Instr::F32Div,
            0x96 => Instr::F32Min,
            0x97 => Instr::F32Max,
            0x98 => Instr::F32Copysign,
            0x99 => Instr::F64Abs,
            0x9A => Instr::F64Neg,
            0x9B => Instr::F64Ceil,
            0x9C => Instr::F64Floor,
            0x9D => Instr::F64Trunc,
            0x9E => Instr::F64Nearest,
            0x9F => Instr::F64Sqrt,

            0xA0 => Instr::F64Add,
            0xA1 => Instr::F64Sub,
            0xA2 => Instr::F64Mul,
            0xA3 => Instr::F64Div,
            0xA4 => Instr::F64Min,
            0xA5 => Instr::F64Max,
            0xA6 => Instr::F64Copysign,
            0xA7 => Instr::I32WrapI64,
            0xA8 => Instr::I32TruncF32S,
            0xA9 => Instr::I32TruncF32U,
            0xAA => Instr::I32TruncF64S,
            0xAB => Instr::I32TruncF64U,
            0xAC => Instr::I64ExtendI32S,
            0xAD => Instr::I64ExtendI32U,
            0xAE => Instr::I64TruncF32S,
            0xAF => Instr::I64TruncF32U,

            0xB0 => Instr::I64TruncF64S,
            0xB1 => Instr::I64TruncF64U,
            0xB2 => Instr::F32ConvertI32S,
            0xB3 => Instr::F32ConvertI32U,
            0xB4 => Instr::F32ConvertI64S,
            0xB5 => Instr::F32ConvertI64U,
            0xB6 => Instr::F32DemoteF64,
            0xB7 => Instr::F64ConvertI32S,
            0xB8 => Instr::F64ConvertI32U,
            0xB9 => Instr::F64ConvertI64S,
            0xBA => Instr::F64ConvertI64U,
            0xBB => Instr::F64PromoteF32,
            0xBC => Instr::I32ReinterpretF32,
            0xBD => Instr::I64ReinterpretF64,
            0xBE => Instr::F32ReinterpretI32,
            0xBF => Instr::F64ReinterpretI64,

            0xC0 => Instr::I32Extend8S,
            0xC1 => Instr::I32Extend16S,
            0xC2 => Instr::I64Extend8S,
            0xC3 => Instr::I64Extend16S,
            0xC4 => Instr::I64Extend32S,
            0xC5 => reserved()?,
            0xC6 => reserved()?,
            0xC7 => reserved()?,
            0xC8 => reserved()?,
            0xC9 => reserved()?,
            0xCA => reserved()?,
            0xCB => reserved()?,
            0xCC => reserved()?,
            0xCD => reserved()?,
            0xCE => reserved()?,
            0xCF => reserved()?,

            0xD0 => Instr::RefNull(self.read_reftype()?),
            0xD1 => Instr::RefIsNull,
            0xD2 => Instr::RefFunc(self.read_u32()),
            0xD3 => Instr::RefEq,
            0xD4 => Instr::RefAsNonNull,
            0xD5 => Instr::BrOnNull(self.read_u32()),
            0xD6 => Instr::BrOnNonNull(self.read_u32()),
            0xD7 => reserved()?,
            0xD8 => reserved()?,
            0xD9 => reserved()?,
            0xDA => reserved()?,
            0xDB => reserved()?,
            0xDC => reserved()?,
            0xDD => reserved()?,
            0xDE => reserved()?,
            0xDF => reserved()?,

            0xE0 => reserved()?,
            0xE1 => reserved()?,
            0xE2 => reserved()?,
            0xE3 => reserved()?,
            0xE4 => reserved()?,
            0xE5 => reserved()?,
            0xE6 => reserved()?,
            0xE7 => reserved()?,
            0xE8 => reserved()?,
            0xE9 => reserved()?,
            0xEA => reserved()?,
            0xEB => reserved()?,
            0xEC => reserved()?,
            0xED => reserved()?,
            0xEE => reserved()?,
            0xEF => reserved()?,

            0xF0 => reserved()?,
            0xF1 => reserved()?,
            0xF2 => reserved()?,
            0xF3 => reserved()?,
            0xF4 => reserved()?,
            0xF5 => reserved()?,
            0xF6 => reserved()?,
            0xF7 => reserved()?,
            0xF8 => reserved()?,
            0xF9 => reserved()?,
            0xFA => reserved()?,
            0xFB => {
                let subcode = self.read_u32();
                self.decode_instr_fb(subcode)
                    .map_err(|e| e.wrap(format!("failed to decode subinstr 0x{:x}", subcode)))?
            }
            0xFC => {
                let subcode = self.read_u32();
                self.decode_instr_fc(subcode)
                    .map_err(|e| e.wrap(format!("failed to decode subinstr 0x{:x}", subcode)))?
            }
            0xFD => {
                let subcode = self.read_u32();
                self.decode_instr_fd(subcode)
                    .map_err(|e| e.wrap(format!("failed to decode subinstr 0x{:x}", subcode)))?
            }
            0xFE => reserved()?,
            0xFF => reserved()?,
        };
        Ok(instr)
    }

    fn decode_instr_fb(&mut self, subcode: u32) -> Result<Instr, DecodingError> {
        let instr = match subcode {
            0x00 => unsupported("struct.new")?,
            0x01 => unsupported("struct.new_default")?,
            0x02 => unsupported("struct.get")?,
            0x03 => unsupported("struct.get_s")?,
            0x04 => unsupported("struct.get_u")?,
            0x05 => unsupported("struct.set")?,
            0x06 => unsupported("array.new")?,
            0x07 => unsupported("array.new_default")?,
            0x08 => unsupported("array.new_fixed")?,
            0x09 => unsupported("array.new_data")?,
            0x0A => unsupported("array.new_elem")?,
            0x0B => unsupported("array.get")?,
            0x0C => unsupported("array.get_s")?,
            0x0D => unsupported("array.get_u")?,
            0x0E => unsupported("array.set")?,
            0x0F => unsupported("array.len")?,

            0x10 => unsupported("array.fill")?,
            0x11 => unsupported("array.copy")?,
            0x12 => unsupported("array.init_data")?,
            0x13 => unsupported("array.init_elem")?,
            0x14 => unsupported("ref.test(ref)")?,
            0x15 => unsupported("ref.test(ref.null)")?,
            0x16 => unsupported("ref.cast(ref)")?,
            0x17 => unsupported("ref.cast(ref.null)")?,
            0x18 => unsupported("br_on_cast")?,
            0x19 => unsupported("br_on_cast_fail")?,
            0x1A => unsupported("any.convert_extern")?,
            0x1B => unsupported("extern.convert_any")?,
            0x1C => unsupported("ref.i31")?,
            0x1D => unsupported("i32.get_s")?,
            0x1E => unsupported("i32.get_u")?,
            0x1F => reserved()?,

            _ => reserved()?,
        };
        Ok(instr)
    }

    fn decode_instr_fc(&mut self, subcode: u32) -> Result<Instr, DecodingError> {
        let instr = match subcode {
            0x00 => Instr::I32TruncSatF32S,
            0x01 => Instr::I32TruncSatF32U,
            0x02 => Instr::I32TruncSatF64S,
            0x03 => Instr::I32TruncSatF64U,
            0x04 => Instr::I64TruncSatF32S,
            0x05 => Instr::I64TruncSatF32U,
            0x06 => Instr::I64TruncSatF64S,
            0x07 => Instr::I64TruncSatF64U,
            0x08 => {
                let x = self.read_u32();
                self.discard_byte(0x00)?;
                Instr::MemoryInit(x)
            }
            0x09 => {
                let x = self.read_u32();
                Instr::MemoryDrop(x)
            }
            0x0A => {
                self.discard_byte(0x00)?;
                self.discard_byte(0x00)?;
                Instr::MemoryCopy
            }
            0x0B => {
                self.discard_byte(0x00)?;
                Instr::MemoryFill
            }
            0x0C => Instr::TableInit(self.read_u32(), self.read_u32()),
            0x0D => Instr::ElemDrop(self.read_u32()),
            0x0E => Instr::TableCopy(self.read_u32(), self.read_u32()),
            0x0F => Instr::TableGrow(self.read_u32()),

            0x10 => Instr::TableSize(self.read_u32()),
            0x11 => Instr::TableFill(self.read_u32()),

            _ => reserved()?,
        };
        Ok(instr)
    }

    fn decode_instr_fd(&mut self, subcode: u32) -> Result<Instr, DecodingError> {
        let instr = match subcode {
            0x00 => Instr::V128Load(self.read_memarg()?),
            0x01 => Instr::V128Load8x8S(self.read_memarg()?),
            0x02 => Instr::V128Load8x8U(self.read_memarg()?),
            0x03 => Instr::V128Load16x4S(self.read_memarg()?),
            0x04 => Instr::V128Load16x4U(self.read_memarg()?),
            0x05 => Instr::V128Load32x2S(self.read_memarg()?),
            0x06 => Instr::V128Load32x2U(self.read_memarg()?),
            0x07 => Instr::V128Load8Splat(self.read_memarg()?),
            0x08 => Instr::V128Load16Splat(self.read_memarg()?),
            0x09 => Instr::V128Load32Splat(self.read_memarg()?),
            0x0A => Instr::V128Load64Splat(self.read_memarg()?),
            0x0B => Instr::V128Store(self.read_memarg()?),
            0x0C => Instr::V128Const(self.read_i128()),
            0x0D => Instr::I8x16Shuffle(<[u8; 16]>::try_from(self.read_bytes(16)).unwrap()),
            0x0E => Instr::I8x16Swizzle,
            0x0F => Instr::I8x16Splat,

            0x10 => Instr::I16x8Splat,
            0x11 => Instr::I32x4Splat,
            0x12 => Instr::I64x2Splat,
            0x13 => Instr::F32x4Splat,
            0x14 => Instr::F64x2Splat,
            0x15 => Instr::I8x16ExtractLaneS(self.read_byte()),
            0x16 => Instr::I8x16ExtractLaneU(self.read_byte()),
            0x17 => Instr::I8x16ReplaceLane(self.read_byte()),
            0x18 => Instr::I16x8ExtractLaneS(self.read_byte()),
            0x19 => Instr::I16x8ExtractLaneU(self.read_byte()),
            0x1A => Instr::I16x8ReplaceLane(self.read_byte()),
            0x1B => Instr::I32x4ExtractLane(self.read_byte()),
            0x1C => Instr::I32x4ReplaceLane(self.read_byte()),
            0x1D => Instr::I64x2ExtractLane(self.read_byte()),
            0x1E => Instr::I64x2ReplaceLane(self.read_byte()),
            0x1F => Instr::F32x4ExtractLane(self.read_byte()),

            0x20 => Instr::F32x4ReplaceLane(self.read_byte()),
            0x21 => Instr::F64x2ExtractLane(self.read_byte()),
            0x22 => Instr::F64x2ReplaceLane(self.read_byte()),
            0x23 => Instr::I8x16Eq,
            0x24 => Instr::I8x16Ne,
            0x25 => Instr::I8x16LtS,
            0x26 => Instr::I8x16LtU,
            0x27 => Instr::I8x16GtS,
            0x28 => Instr::I8x16GtU,
            0x29 => Instr::I8x16LeS,
            0x2A => Instr::I8x16LeU,
            0x2B => Instr::I8x16GeS,
            0x2C => Instr::I8x16GeU,
            0x2D => Instr::I16x8Eq,
            0x2E => Instr::I16x8Ne,
            0x2F => Instr::I16x8LtS,

            0x30 => Instr::I16x8LtU,
            0x31 => Instr::I16x8GtS,
            0x32 => Instr::I16x8GtU,
            0x33 => Instr::I16x8LeS,
            0x34 => Instr::I16x8LeU,
            0x35 => Instr::I16x8GeS,
            0x36 => Instr::I16x8GeU,
            0x37 => Instr::I32x4Eq,
            0x38 => Instr::I32x4Ne,
            0x39 => Instr::I32x4LtS,
            0x3A => Instr::I32x4LtU,
            0x3B => Instr::I32x4GtS,
            0x3C => Instr::I32x4GtU,
            0x3D => Instr::I32x4LeS,
            0x3E => Instr::I32x4LeU,
            0x3F => Instr::I32x4GeS,

            0x40 => Instr::I32x4GeU,
            0x41 => Instr::F32x4Eq,
            0x42 => Instr::F32x4Ne,
            0x43 => Instr::F32x4Lt,
            0x44 => Instr::F32x4Gt,
            0x45 => Instr::F32x4Le,
            0x46 => Instr::F32x4Ge,
            0x47 => Instr::F64x2Eq,
            0x48 => Instr::F64x2Ne,
            0x49 => Instr::F64x2Lt,
            0x4A => Instr::F64x2Gt,
            0x4B => Instr::F64x2Le,
            0x4C => Instr::F64x2Ge,
            0x4D => Instr::V128Not,
            0x4E => Instr::V128And,
            0x4F => Instr::V128Andnot,

            0x50 => Instr::V128Or,
            0x51 => Instr::V128Xor,
            0x52 => Instr::V128Bitselect,
            0x53 => Instr::V128AnyTrue,
            0x54 => Instr::V128Load8Lane(self.read_memarg()?, self.read_byte()),
            0x55 => Instr::V128Load16Lane(self.read_memarg()?, self.read_byte()),
            0x56 => Instr::V128Load32Lane(self.read_memarg()?, self.read_byte()),
            0x57 => Instr::V128Load64Lane(self.read_memarg()?, self.read_byte()),
            0x58 => Instr::V128Store8Lane(self.read_memarg()?, self.read_byte()),
            0x59 => Instr::V128Store16Lane(self.read_memarg()?, self.read_byte()),
            0x5A => Instr::V128Store32Lane(self.read_memarg()?, self.read_byte()),
            0x5B => Instr::V128Store64Lane(self.read_memarg()?, self.read_byte()),
            0x5C => Instr::V128Load32Zero(self.read_memarg()?),
            0x5D => Instr::V128Load64Zero(self.read_memarg()?),
            0x5E => Instr::F32x4DemoteF64x2Zero,
            0x5F => Instr::F64x2PromoteLowF32x4,

            0x60 => Instr::I8x16Abs,
            0x61 => Instr::I8x16Neg,
            0x62 => Instr::I8x16Popcnt,
            0x63 => Instr::I8x16AllTrue,
            0x64 => Instr::I8x16Bitmask,
            0x65 => Instr::I8x16NarrowI16x8S,
            0x66 => Instr::I8x16NarrowI16x8U,
            0x67 => Instr::F32x4Ceil,
            0x68 => Instr::F32x4Floor,
            0x69 => Instr::F32x4Trunc,
            0x6A => Instr::F32x4Nearest,
            0x6B => Instr::I8x16Shl,
            0x6C => Instr::I8x16ShrS,
            0x6D => Instr::I8x16ShrU,
            0x6E => Instr::I8x16Add,
            0x6F => Instr::I8x16AddSatS,

            0x70 => Instr::I8x16AddSatU,
            0x71 => Instr::I8x16Sub,
            0x72 => Instr::I8x16SubSatS,
            0x73 => Instr::I8x16SubSatU,
            0x74 => Instr::F64x2Ceil,
            0x75 => Instr::F64x2Floor,
            0x76 => Instr::I8x16MinS,
            0x77 => Instr::I8x16MinU,
            0x78 => Instr::I8x16MaxS,
            0x79 => Instr::I8x16MaxU,
            0x7A => Instr::F64x2Trunc,
            0x7B => Instr::I8x16AvgrU,
            0x7C => Instr::I16x8ExtaddPairwiseI8x16S,
            0x7D => Instr::I16x8ExtaddPairwiseI8x16U,
            0x7E => Instr::I32x4ExtaddPairwiseI16x8S,
            0x7F => Instr::I32x4ExtaddPairwiseI16x8U,

            0x80 => Instr::I16x8Abs,
            0x81 => Instr::I16x8Neg,
            0x82 => Instr::I16x8Q15mulrSatS,
            0x83 => Instr::I16x8AllTrue,
            0x84 => Instr::I16x8Bitmask,
            0x85 => Instr::I16x8NarrowI32x4S,
            0x86 => Instr::I16x8NarrowI32x4U,
            0x87 => Instr::I16x8ExtendLowI8x16S,
            0x88 => Instr::I16x8ExtendHighI8x16S,
            0x89 => Instr::I16x8ExtendLowI8x16U,
            0x8A => Instr::I16x8ExtendHighI8x16U,
            0x8B => Instr::I16x8Shl,
            0x8C => Instr::I16x8ShrS,
            0x8D => Instr::I16x8ShrU,
            0x8E => Instr::I16x8Add,
            0x8F => Instr::I16x8AddSatS,

            0x90 => Instr::I16x8AddSatU,
            0x91 => Instr::I16x8Sub,
            0x92 => Instr::I16x8SubSatS,
            0x93 => Instr::I16x8SubSatU,
            0x94 => Instr::F64x2Nearest,
            0x95 => Instr::I16x8Mul,
            0x96 => Instr::I16x8MinS,
            0x97 => Instr::I16x8MinU,
            0x98 => Instr::I16x8MaxS,
            0x99 => Instr::I16x8MaxU,
            0x9A => reserved()?,
            0x9B => Instr::I16x8AvgrU,
            0x9C => Instr::I16x8ExtmulLowI8x16S,
            0x9D => Instr::I16x8ExtmulHighI8x16S,
            0x9E => Instr::I16x8ExtmulLowI8x16U,
            0x9F => Instr::I16x8ExtmulHighI8x16U,

            0xA0 => Instr::I32x4Abs,
            0xA1 => Instr::I32x4Neg,
            0xA2 => reserved()?,
            0xA3 => Instr::I32x4AllTrue,
            0xA4 => Instr::I32x4Bitmask,
            0xA5 => reserved()?,
            0xA6 => reserved()?,
            0xA7 => Instr::I32x4ExtendLowI16x8S,
            0xA8 => Instr::I32x4ExtendHighI16x8S,
            0xA9 => Instr::I32x4ExtendLowI16x8U,
            0xAA => Instr::I32x4ExtendHighI16x8U,
            0xAB => Instr::I32x4Shl,
            0xAC => Instr::I32x4ShrS,
            0xAD => Instr::I32x4ShrU,
            0xAE => Instr::I32x4Add,
            0xAF => reserved()?,

            0xB0 => reserved()?,
            0xB1 => Instr::I32x4Sub,
            0xB2 => reserved()?,
            0xB3 => reserved()?,
            0xB4 => reserved()?,
            0xB5 => Instr::I32x4Mul,
            0xB6 => Instr::I32x4MinS,
            0xB7 => Instr::I32x4MinU,
            0xB8 => Instr::I32x4MaxS,
            0xB9 => Instr::I32x4MaxU,
            0xBA => Instr::I32x4DotI16x8S,
            0xBC => Instr::I32x4ExtmulLowI16x8S,
            0xBD => Instr::I32x4ExtmulHighI16x8S,
            0xBE => Instr::I32x4ExtmulLowI16x8U,
            0xBF => Instr::I32x4ExtmulHighI16x8U,

            0xC0 => Instr::I64x2Abs,
            0xC1 => Instr::I64x2Neg,
            0xC2 => reserved()?,
            0xC3 => Instr::I64x2AllTrue,
            0xC4 => Instr::I64x2Bitmask,
            0xC5 => reserved()?,
            0xC6 => reserved()?,
            0xC7 => Instr::I64x2ExtendLowI32x4S,
            0xC8 => Instr::I64x2ExtendHighI32x4S,
            0xC9 => Instr::I64x2ExtendLowI32x4U,
            0xCA => Instr::I64x2ExtendHighI32x4U,
            0xCB => Instr::I64x2Shl,
            0xCC => Instr::I64x2ShrS,
            0xCD => Instr::I64x2ShrU,
            0xCE => Instr::I64x2Add,
            0xCF => reserved()?,

            0xD0 => reserved()?,
            0xD1 => Instr::I64x2Sub,
            0xD2 => reserved()?,
            0xD3 => reserved()?,
            0xD4 => reserved()?,
            0xD5 => Instr::I64x2Mul,
            0xD6 => Instr::I64x2Eq,
            0xD7 => Instr::I64x2Ne,
            0xD8 => Instr::I64x2LtS,
            0xD9 => Instr::I64x2GtS,
            0xDA => Instr::I64x2LeS,
            0xDB => Instr::I64x2GeS,
            0xDC => Instr::I64x2ExtmulLowI32x4S,
            0xDD => Instr::I64x2ExtmulHighI32x4S,
            0xDE => Instr::I64x2ExtmulLowI32x4U,
            0xDF => Instr::I64x2ExtmulHighI32x4U,

            0xE0 => Instr::F32x4Abs,
            0xE1 => Instr::F32x4Neg,
            0xE2 => reserved()?,
            0xE3 => Instr::F32x4Sqrt,
            0xE4 => Instr::F32x4Add,
            0xE5 => Instr::F32x4Sub,
            0xE6 => Instr::F32x4Mul,
            0xE7 => Instr::F32x4Div,
            0xE8 => Instr::F32x4Min,
            0xE9 => Instr::F32x4Max,
            0xEA => Instr::F32x4Pmin,
            0xEB => Instr::F32x4Pmax,
            0xEC => Instr::F64x2Abs,
            0xED => Instr::F64x2Neg,
            0xEF => Instr::F64x2Sqrt,

            0xF0 => Instr::F64x2Add,
            0xF1 => Instr::F64x2Sub,
            0xF2 => Instr::F64x2Mul,
            0xF3 => Instr::F64x2Div,
            0xF4 => Instr::F64x2Min,
            0xF5 => Instr::F64x2Max,
            0xF6 => Instr::F64x2Pmin,
            0xF7 => Instr::F64x2Pmax,
            0xF8 => Instr::I32x4TruncSatF32x4S,
            0xF9 => Instr::I32x4TruncSatF32x4U,
            0xFA => Instr::F32x4ConvertI32x4S,
            0xFB => Instr::F32x4ConvertI32x4U,
            0xFC => Instr::I32x4TruncSatF64x2SZero,
            0xFD => Instr::I32x4TruncSatF64x2UZero,
            0xFE => Instr::F64x2ConvertLowI32x4S,
            0xFF => Instr::F64x2ConvertLowI32x4U,

            0x100 => Instr::I8x16RelaxedSwizzle,
            0x101 => Instr::I32x4RelaxedTruncF32x4S,
            0x102 => Instr::I32x4RelaxedTruncF32x4U,
            0x103 => Instr::I32x4RelaxedTruncF64x2S,
            0x104 => Instr::I32x4RelaxedTruncF64x2U,
            0x105 => Instr::F32x4RelaxedMadd,
            0x106 => Instr::F32x4RelaxedNmadd,
            0x107 => Instr::F64x2RelaxedMadd,
            0x108 => Instr::F64x2RelaxedNmadd,
            0x109 => Instr::I8x16RelaxedLaneselect,
            0x10A => Instr::I16x8RelaxedLaneselect,
            0x10B => Instr::I32x4RelaxedLaneselect,
            0x10C => Instr::I64x2RelaxedLaneselect,
            0x10D => Instr::F32x4RelaxedMin,
            0x10E => Instr::F32x4RelaxedMax,
            0x10F => Instr::F64x2RelaxedMin,

            0x110 => Instr::F64x2RelaxedMax,
            0x111 => Instr::I16x8RelaxedQ15mulrS,
            0x112 => Instr::I16x8RelaxedDotI8x16I7x16S,
            0x113 => Instr::I32x4RelaxedDotI8x16I7x16AddS,

            _ => reserved()?,
        };
        Ok(instr)
    }
}
